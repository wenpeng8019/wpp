/*
** 2024-03-30
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This source code file implements a command-line utility that converts
** the text log file generated by althttpd into an SQLite database.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <ctype.h>
#include "sqlite3.h"
#include "VERSION.h"

/*
** Number of elements in an array
*/
#define ArraySize(X)  (int)(sizeof(X)/sizeof(X[0]))

/*
** Instructions for the user.
*/
static const char zHelp[] = 
  "Usage:  logtodb OPTIONS\n"
  "\n"
  "Convert CSV logfile content contained in the --logfile into entries\n"
  "in an SQLite database identified by the --db option.\n"
  "\n"
  "Extra columns that are not found in the logfile CSV are added to\n"
  "the SQLite table:\n"
  "   domain     -- Domain name from the url column\n"
  "   cgi        -- True for CGI requests\n"
  "\n"
  "The --db option is required.  If the --logfile option is omitted, then\n"
  "content is read from standard input.\n"
  "\n"
  "Options:\n"
  "\n"
  "  --bufsize N               Size of the input buffer (debug use only)\n"
  "  --db  DATABASE            Name of database file to create and populate\n"
  "  -f                        Monitor LOGFILE as per \"tail -f\"\n"
  "  --keep S                  Keep only the last S seconds of data\n"
  "  --logfile LOGFILE         The logfile to interpret\n"
  "  --reset                   Delete any prior content in DATABASE\n"
  "  --tail N                  Read only the last N bytes of the log file\n"
  "  -v                        Debugging output\n"
  "  --version                 Show version information for this program\n"
;

/*
** Database connection setup.
**
** NOTES:
**
**    *  (19) is derived from (16) and (3).  If (16) is an 
**       integer N, then (19) is the first N bytes of (3) with the
**       scheme and hostname removed.  If (16) is text of the form
**       "N+TAIL" then (19) is the first N bytes of (3) with scheme and
**       hostname removed and with TAIL appended.  This latter case occurs,
**       for example, when althttpd constructs a path that includes
**       "not-found.html" or similar at the end, which is text not
**       contained within (3).
*/
static const char zSetup[] =
  "PRAGMA journal_mode=WAL;\n"
  "CREATE TABLE IF NOT EXISTS log(\n"
  /*  1 */ "  date TEXT,  -- Time (ISO8601)\n"
  /*  2 */ "  ip TEXT,    -- IP address\n"
  /*  3 */ "  url TEXT,   -- Request URI\n"
  /*  4 */ "  ref TEXT,   -- Referer\n"
  /*  5 */ "  code INT,   -- Result code. ex: 200, 404, etc\n"
  /*  6 */ "  nIn INT,    -- Bytes in request\n"
  /*  7 */ "  nOut INT,   -- Bytes in reply\n"
  /*  8 */ "  t1 INT, t2 INT,  -- Process time (user, system) milliseconds\n"
  /* 10 */ "  t3 INT, t4 INT,  -- CGI script time (user, system) milliseconds\n"
  /* 12 */ "  t5 INT,          -- Wall-clock time, milliseconds\n"
  /* 13 */ "  nreq INT,   -- Sequence number of this request\n"
  /* 14 */ "  agent TEXT, -- User agent\n"
  /* 15 */ "  user TEXT,  -- Remote user\n"
  /* 16 */ "  n INT,      -- Bytes of url that are in SCRIPT_NAME\n"
  /* 17 */ "  lineno INT, -- Althttpd line that generated this entry\n"
  /* 18 */ "  domain,     -- Domain name from url\n"
  /* 19 */ "  scriptname, -- Name of the source file or script\n"
  /* 20 */ "  uriofst,    -- Offset in url to the REQUEST_URI\n"
           "  cgi INT COMPUTED ALWAYS AS (t3+t4>0), -- TRUE for CGI\n"
           "  CHECK (date(date) IS NOT NULL)"
  ");"
;

/*
** SQL to insert into the log table
*/
static const char zInsert[] = 
  "INSERT INTO log VALUES(?1,?2,?3,?4,?5,?6,?7,?8,?9,?10,"
                         "?11,?12,?13,?14,?15,?16,?17,?18,?19,?20);"
;

/* Number of columns in the CSV of the logfile.
**
** This is different from the number of columns in the LOG table.
** The log table has extra columns that are added.
*/
#define NLOGCOL  17

/* Which columns should be integers? */
static const int isInt[] = {
  0,  /* date */
  0,  /* ip */
  0,  /* url */
  0,  /* ref */
  1,  /* code */

  1,  /* nIn */
  1,  /* nOut */
  1,  /* t1 */
  1,  /* t2 */
  1,  /* t3 */

  1,  /* t4 */
  1,  /* t5 */
  1,  /* nreq */
  0,  /* agent */
  0,  /* user */

  0,  /* n */
  1   /* lineno */
};

/*
** State vector passed around to various subroutines.
*/
typedef struct Logger Logger;
struct Logger {
  sqlite3 *db;            /* The database connection */
  sqlite3_stmt *pIns;     /* INSERT statement */
  sqlite3_stmt *pBegin;   /* BEGIN TRANSACTION statement */
  sqlite3_stmt *pCommit;  /* COMMIT statement */
  FILE *pIn;              /* Input stream */
  int bTrace;             /* Trace flag */
  int nPause;             /* Pause by this amount at end of input */
  int nKeep;              /* Retain only this many seconds of data */
  int nBuf;               /* Bytes of content in zBuf */
  int nStart;             /* Prefix of zBuf already consumed */
  int szBuf;              /* Size of zBuf[] in bytes */
  char *zBuf;             /* Working buffer */
};

/*
** Examine the URL provided as an argument.  Extract the domain name.
** Convert the domain name to lower case, and remove any "www." prefix.
** Bind the result as the 18-th field in the Logger.pIns statement.
*/
static void setDomainName(Logger *p, const char *zUrl){
  int i, j;
  int seenDot = 0;
  char zDomain[200];
  for(i=0; zUrl[i] && zUrl[i]!='/'; i++){}
  if( zUrl[i]==0 ) return;
  if( zUrl[i+1]!='/' ) return;
  zUrl += i+2;
  if( sqlite3_strnicmp(zUrl, "www.", 4)==0 ) zUrl += 4;
  for(i=0; zUrl[i] && (zUrl[i]!='/' && zUrl[i]!=':'); i++){}
  if( i>=(int)sizeof(zDomain) ) i = (int)sizeof(zDomain)-1;
  for(j=0; j<i; j++){
    zDomain[j] = tolower(zUrl[j]);
  }
  zDomain[i] = 0;
  for(j=0; zDomain[j]; j++){
    char c = zDomain[j];
    if( (c>='a' && c<='z') || (c>='0' && c<='9')  ) continue;
    if( c=='.' ){ seenDot = 1;  continue; }
    if( c=='-' ) continue;
    break;
  }
  if( zDomain[j]==0 && seenDot ){
    sqlite3_bind_text(p->pIns, 18, zDomain, i, SQLITE_TRANSIENT);
  }else{
    sqlite3_bind_null(p->pIns, 18);
  }
}

/*
** Find the SCRIPT_NAME and bind it into the 19-field.
** Bind the offset to the start of the REQUEST_URI into 20-field.
*/
static void setScriptName(
  Logger *p,             /* The logger context */
  const char *zUrl,      /* Base URL */
  int n,                 /* Bytes of base URL in script name */
  const char *zExtra     /* NULL or "N+TAIL" where N is n and TAIL is an
                         ** additional suffix */
){
  int i;
  sqlite3_bind_null(p->pIns, 19);
  sqlite3_bind_null(p->pIns, 20);
  if( zUrl==0 ) return;
  if( n<=0 || n>(int)strlen(zUrl) ) return;
  for(i=1; i<n && zUrl[i] && (zUrl[i]!='/' || zUrl[i-1]!='/'); i++){}
  if( i>=n || zUrl[i]!='/' ) return;
  for(i++; i<n && zUrl[i] && zUrl[i]!='/'; i++){}
  if( zExtra==0 ){
    if( i>=n || zUrl[i]!='/' ) return;
    sqlite3_bind_text(p->pIns, 19, &zUrl[i], n-i, SQLITE_TRANSIENT);
    sqlite3_bind_int(p->pIns, 20, i+1);
  }else{
    char *zSN;
    if( i>n ) return;
    zSN = sqlite3_mprintf("%.*s%s", n-i, &zUrl[i], zExtra);
    sqlite3_bind_text(p->pIns, 19, zSN, -1, sqlite3_free);
    sqlite3_bind_int(p->pIns, 20, (int)strlen(zUrl));
  }
}

/*
** Return string if string z[] represents an integer value.
*/
static int isInteger(const char *z){
  if( z[0]=='-' || z[0]=='+' ) z++;
  while( z[0]>='0' && z[0]<='9' ) z++;
  return z[0]==0;
}


/*
** Read CSV values from the input buffer and bind those values
** to the INSERT statement.
**
**   *  If no \n is seen, then return 1 and do not consume input.
**
**   *  If a \n is seen but some other error occurs, such as too many or
**      too few columns, or malformed input, then return 2 and
**      do consume input up to and including the next \n.
**
**   *  On success, consume input up to and including the terminating \n
**      and return 0.
**
** This routine might modify p->zBuf[] by inserting zero terminators and
** resolving escape sequences.  Bindings might reference p->zBuf[] so the
** content of p->zBuf[] should not be futher changed until after the
** INSERT statement has been executed.
*/
static int readOneCsvLine(Logger *p){
  int i = 0;    /* Column number */
  int j;        /* Position in zLine */
  char *zLine;  /* One complete line of text */
  char *zEnd;   /* End of the line */
  char c;       /* Next character */
  char *zUrl;   /* Text of the URL */
  char *zDate;  /* Text of the DATE field */

  if( p->nStart>=p->nBuf ) return 1;
  zLine = &p->zBuf[p->nStart];
  zEnd = strchr(zLine, '\n');
  if( zEnd==0 ){
    if( p->nStart==0 ) p->nBuf = 0;
    return 1;
  }
  p->nStart = (int)(zEnd - p->zBuf) + 1;
  if( zEnd>zLine && zEnd[-1]=='\r' ) zEnd--;
  *zEnd = 0;
  i = 0;
  zUrl = 0;
  zDate = 0;
  while( (c = zLine[0])!=0 ){
    if( c=='"' ){
      int fixEsc = 0;
      zLine++;
      j = 0;
      while( 1 ){
        c = zLine[j];
        if( c==0 ){
          if( p->bTrace ) printf("Unterminated double-quote\n");
          return 2;
        }
        if( c=='"' ){
          if( zLine[j+1]=='"' ){
            j++;
            fixEsc = 1;
          }else{
            break;
          }
        }
        j++;
      }
      zLine[j] = 0;
      if( fixEsc ){
        int from, to;
        for(from=to=0; zLine[from]; from++, to++){
          char c2 = zLine[from];
          if( c2=='"' ) c2 = zLine[++from];
          zLine[to] = c2;
        }
        zLine[to] = 0;
      }
      if( isInt[i] ){
        if( p->bTrace ){
          printf("INT column %d has a string value: \"%s\"\n", i+1, zLine);
        }
        return 2;
      }
      i++;
      sqlite3_bind_text(p->pIns, i, zLine, -1, SQLITE_STATIC);
      if( i==1 ){
        zDate = zLine;
      }else if( i==3 ){
        zUrl = zLine;
        setDomainName(p, zLine);
      }else if( i==16 ){
        int kk = 1;
        while( zLine[kk] && zLine[kk]!='+' ){ kk++; }
        if( zLine[kk]=='+' ) kk++;
        setScriptName(p, zUrl, atoi(zLine), &zLine[kk]);
      }
      zLine += j + 1;
      if( zLine[0]==',' ) zLine++;
    }else{
      j = 0;
      while( 1 ){
        c = zLine[j];
        if( c==0 || c==',' ){
          zLine[j] = 0;
          if( isInt[i] || isInteger(zLine) ){
            int v = atoi(zLine);
            i++;
            sqlite3_bind_int(p->pIns, i, v);
            if( i==16 ){
              setScriptName(p, zUrl, v, 0);
            }
          }else{
            i++;
            sqlite3_bind_text(p->pIns, i, zLine, -1, SQLITE_TRANSIENT);
            if( i==1 ){
              zDate = zLine;
            }else if( i==3 ){
              zUrl = zLine;
              setDomainName(p, zLine);
            }
          }
          break;
        }
        j++;
      }
      zLine += j;
      if( c==',' ) zLine++;
    }
  }
  if( p->bTrace ){
    printf("Line of %d bytes, %d columns.  %d bytes left\n",
           (int)(zLine - &p->zBuf[p->nStart]), i, p->nBuf - p->nStart);
  }
  return i!=NLOGCOL && (zDate==0 || strlen(zDate)!=19);
}

/*
** Read text from the input in order to replenish the input buffer.
*/
static int refillBuffer(Logger *p){
  size_t got;
  if( p->nStart>0 ){
    int n = p->nBuf - p->nStart;
    if( n>0 ){
      memmove(p->zBuf, p->zBuf+p->nStart, n);
      p->nBuf = n;
    }else{
      p->nBuf = 0;
    }
    p->nStart = 0;
  }
  got = fread(p->zBuf+p->nBuf, 1, p->szBuf-p->nBuf-1, p->pIn);
  if( got>0 ){
    p->nBuf += got;
    assert( p->nBuf<p->szBuf );
    p->zBuf[p->nBuf] = 0;
    if( p->bTrace ){
      printf("READ %d bytes.  Buffer now holds %d bytes\n", (int)got, p->nBuf);
    }
  }else if( p->bTrace ){
    printf("No new content\n");
  }
  return (int)got;
}

/*
** Run an SQL statement.  Retry after a delay if SQLITE_BUSY is returned.
*/
static void runSql(Logger *p, sqlite3_stmt *pStmt){
  int rc;
  int cnt = 0;
  while( 1 ){
    if( p->bTrace ) printf("%s\n", sqlite3_sql(pStmt));
    rc = sqlite3_step(pStmt);
    sqlite3_reset(pStmt);
    if( rc==SQLITE_DONE ) break;
    if( rc==SQLITE_BUSY ){
      cnt++;
      if( cnt>10 ){
        fprintf(stderr, "TIMEOUT running %s\n", sqlite3_sql(pStmt));
        exit(1);
      }
      if( p->bTrace ) printf("... Pause due to BUSY\n");
      sleep(1 + 2*(cnt>5));
      continue;
    }
    if( p->bTrace ){
      printf("... ERROR\n");
    }
    break;
  }
}

/*
** Return the size of file zFile in bytes.  Return -1 if the
** file does not exist.
*/
static sqlite3_int64 fileSize(const char *zFile){
  struct stat statbuf;
  int rc;
  memset(&statbuf, 0, sizeof(statbuf));
  rc = stat(zFile, &statbuf);
  if( rc ) return -1;
  return (sqlite3_int64)statbuf.st_size;
}

/*
** Return the value of a hexadecimal digit.  Return -1 if the input
** is not a hex digit.
*/
static int hexDigitValue(char c){
  if( c>='0' && c<='9' ) return c - '0';
  if( c>='a' && c<='f' ) return c - 'a' + 10;
  if( c>='A' && c<='F' ) return c - 'A' + 10;
  return -1;
}

/*
** Interpret zArg as an integer value, possibly with suffixes.
*/
static sqlite3_int64 integerValue(const char *zArg){
  sqlite3_int64 v = 0;
  static const struct { char *zSuffix; int iMult; } aMult[] = {
    { "KiB", 1024 },
    { "MiB", 1024*1024 },
    { "GiB", 1024*1024*1024 },
    { "KB",  1000 },
    { "MB",  1000000 },
    { "GB",  1000000000 },
    { "K",   1000 },
    { "M",   1000000 },
    { "G",   1000000000 },
  };
  int i;
  int isNeg = 0;
  if( zArg[0]=='-' ){
    isNeg = 1;
    zArg++;
  }else if( zArg[0]=='+' ){
    zArg++;
  }
  if( zArg[0]=='0' && zArg[1]=='x' ){
    int x;
    zArg += 2;
    while( (x = hexDigitValue(zArg[0]))>=0 ){
      v = (v<<4) + x;
      zArg++;
    }
  }else{
    while( isdigit(zArg[0]) ){
      v = v*10 + zArg[0] - '0';
      zArg++;
    }
  }
  for(i=0; i<ArraySize(aMult); i++){
    if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 ){
      v *= aMult[i].iMult;
      break;
    }
  }
  return isNeg? -v : v;
}


int main(int argc, char **argv){
  const char *zDb = 0;
  const char *zLog = 0;
  int i;
  int rc;
  int bReset = 0;
  sqlite3_int64 nTail = 0;
  char *zErr = 0;
  Logger s;

  /* Initialize variablse */
  memset(&s, 0, sizeof(s));
  s.szBuf = 1000000;

  /* Parse command-line arguments */
  for(i=1; i<argc; i++){
    const char *zArg = argv[i];
    if( zArg[0]=='-' && zArg[1]=='-' && zArg[2]!=0 ) zArg++;
    if( strcmp(zArg, "-db")==0 ){
      if( zDb!=0 ){
        fprintf(stderr, "multiple --db options\n");
        exit(1);
      }
      if( i==argc-1 ){
        fprintf(stderr, "no argument to --db\n");
        exit(1);
      }
      zDb = argv[++i];
      continue;
    }
    if( strcmp(zArg, "-logfile")==0 ){
      if( zLog!=0 ){
        fprintf(stderr, "multiple --logfile options\n");
        exit(1);
      }
      if( i==argc-1 ){
        fprintf(stderr, "no argument to --logfile\n");
        exit(1);
      }
      zLog = argv[++i];
      continue;
    }
    if( strcmp(zArg, "-bufsize")==0 ){
      if( i==argc-1 ){
        fprintf(stderr, "no argument to --bufsize\n");
        exit(1);
      }
      s.szBuf = integerValue(argv[++i]);
      continue;
    }
    if( strcmp(zArg, "-keep")==0 ){
      if( i==argc-1 ){
        fprintf(stderr, "no argument to --keep\n");
        exit(1);
      }
      s.nKeep = atoi(argv[++i]);
      continue;
    }
    if( strcmp(zArg, "-v")==0 ){
      s.bTrace++;
      continue;
    }
    if( strcmp(zArg, "-f")==0 ){
      s.nPause = 10;
      continue;
    }
    if( strcmp(zArg, "-reset")==0 ){
      bReset = 1;
      continue;
    }
    if( strcmp(zArg, "-tail")==0 ){
      if( i==argc-1 ){
        fprintf(stderr, "no argument to --keep\n");
        exit(1);
      }
      nTail = integerValue(argv[++i]);
      continue;
    }
    if( strcmp(zArg, "-help")==0 || strcmp(zArg, "-?")==0 ){
      printf("%s", zHelp);
      exit(0);
    }
    if( strcmp(zArg, "-version")==0 ){
      printf("Version " RELEASE_VERSION " " MANIFEST_DATE "\n");
      printf("SQLite %s %.35s\n", sqlite3_libversion(), sqlite3_sourceid());
      printf("Compiled on " __DATE__ " using " COMPILER "\n");
      exit(0);
    }
    fprintf(stderr, "unknown command-line argument: \"%s\"\n", argv[i]);
    fprintf(stderr, "%s", zHelp);
    exit(1);
  }
  if( zDb==0 ){
    fprintf(stderr, "No database file specified.  Use the --db option.\n");
    exit(1);
  }
  if( s.szBuf<100 ) s.szBuf = 100;
  s.zBuf = malloc( s.szBuf+1 );
  if( s.zBuf==0 ){
    fprintf(stderr, "Unable to allocate %d bytes for an input buffer\n",
            s.szBuf);
    exit(1);
  }


  /* Open the input source */
  if( zLog==0 || strcmp(zLog, "-")==0 ){
    s.pIn = stdin;
  }else{
    s.pIn = fopen(zLog, "rb");
    if( s.pIn==0 ){
      fprintf(stderr, "cannot open log file \"%s\" for reading\n", zLog);
      exit(1);
    }
    if( nTail<=0 && s.nKeep>0 ){
      nTail = 50*250*s.nKeep;
    }
    if( nTail>0 ){
      if( nTail<fileSize(zLog) ) fseek(s.pIn, -nTail, SEEK_END);
    }
  }

  /* Open the database file */
  rc = sqlite3_open(zDb, &s.db);
  if( rc!=SQLITE_OK ){
    fprintf(stderr, "cannot open database \"%s\"\n", zDb);
    exit(1);
  }
  rc = sqlite3_exec(s.db, zSetup, 0, 0, &zErr);
  if( rc!=SQLITE_OK ){
    fprintf(stderr, "cannot initialize the database \"%s\": %s\n", zDb, zErr);
    exit(1);
  }
  if( bReset ){
    sqlite3_exec(s.db, "DELETE FROM log;", 0, 0, 0);
  }
  rc = sqlite3_prepare_v2(s.db, zInsert, -1, &s.pIns, 0);
  if( rc!=SQLITE_OK ){
    fprintf(stderr, "cannot prepare an INSERT statement\n");
    exit(1);
  }
  rc = sqlite3_prepare_v2(s.db, "BEGIN IMMEDIATE;", -1, &s.pBegin, 0);
  if( rc!=SQLITE_OK ){
    fprintf(stderr, "cannot prepare an BEGIN TRANSACTION statement\n");
    exit(1);
  }
  rc = sqlite3_prepare_v2(s.db, "COMMIT;", -1, &s.pCommit, 0);
  if( rc!=SQLITE_OK ){
    fprintf(stderr, "cannot prepare an COMMIT TRANSACTION statement\n");
    exit(1);
  }

  /* Process input */
  while( 1 ){
    int bInTrans = 0;
    int rc;
    rc = refillBuffer(&s);
    if( rc==0 ){
      if( s.nKeep>0 ){
        char *zSql = sqlite3_mprintf(
          "DELETE FROM log WHERE date<datetime('now','-%d seconds')",
          s.nKeep
        );
        sqlite3_exec(s.db, zSql, 0, 0, 0);
        if( s.bTrace ){
          printf("%s;\n", zSql);
          printf("Purged %d entries\n", sqlite3_changes(s.db));
        }
        sqlite3_free(zSql);
      }
      if( s.nPause ){
        sqlite3_int64 sz, szAfter;
        sz = zLog ? fileSize(zLog) : 0;
        if( s.bTrace ){
          printf("Pause...\n");
          fflush(stdout);
        }
        do{
          sleep(s.nPause);
          szAfter = zLog ? fileSize(zLog) : 0;
        }while( szAfter<0 );
        if( szAfter<sz ){
          fclose(s.pIn);
          s.pIn = fopen(zLog, "rb");
          if( s.pIn==0 ){
            fprintf(stderr, "failed to reopen \"%s\"\n", zLog);
            exit(1);
          }
        }
        continue;
      }
      break;
    }
    while( 1 ){
      int rc;
      rc = readOneCsvLine(&s);
      if( rc==1 ) break;
      if( rc==2 ) continue;
      if( !bInTrans ){
        runSql(&s, s.pBegin);
        bInTrans = 1;
      }
      runSql(&s, s.pIns);
    }
    if( bInTrans ){
      runSql(&s, s.pCommit);
      bInTrans = 0;
    }
  }

  /* Shutdown */
  sqlite3_finalize(s.pIns);
  sqlite3_finalize(s.pBegin);
  sqlite3_finalize(s.pCommit);
  free(s.zBuf);
  fclose(s.pIn);
  sqlite3_close(s.db);
  return 0;
}
